✔ Setup postgres database on development machine @done(25-08-19 08:18)
  ✔ Install PostgreSQL @done(25-08-19 08:18)
  ✔ Create a new database for the project @done(25-08-19 08:18)
  ✔ Configure database connection settings in the application @done(25-08-19 08:18)
    ✔ Save connection details in a `.env` file @done(25-08-19 08:18)
    ✔ Backup secrets somewhere secure @done(25-08-19 08:18)

✔ Create database schema @started(25-08-19 08:26) @done(25-08-23 07:32) @lasted(3d23h6m35s)
  ✔ Define models for the application @started(25-08-21 00:30) @done(25-08-23 07:32) @lasted(2d7h2m36s)
  ✔ Use a migration tool to create the initial schema @done(25-08-23 07:32)
    ✔ Run migrations to set up tables and relationships @done(25-08-23 07:32)
  ✔ Verify schema by checking the database structure @done(25-08-23 07:32)

✔ Seed the database with initial data from the provided CSV files @started(25-08-23 07:44) @done(25-09-20 16:00) @lasted(4w8h16m55s)
  ✔ Write scripts to read CSV files and insert data into the database @started(25-09-18 15:12) @done(25-09-20 16:00) @lasted(2d48m56s)
  ✔ Ensure data integrity and consistency during the seeding process @started(25-09-18 15:12) @done(25-09-20 16:00) @lasted(2d48m56s)
  ✔ Validate that the data has been correctly inserted by querying the database @done(25-09-20 16:00)

✔ Implement basic CRUD operations for the main entities @done(25-09-20 16:46)
  ✔ Create endpoints for creating, reading, updating, and deleting records @done(25-09-20 16:46)
    ✔ Test each endpoint to ensure they work as expected @done(25-09-24 09:30)
✔ Set up a development environment for testing @done(25-09-24 09:30)
  - Use a testing framework to write unit and integration tests
    ✔ Create test cases for the CRUD operations (CrudIntegrationTests) @done(25-09-24 09:30)
    ✔ Run tests to ensure functionality and catch any bugs early @done(25-09-24 09:30)
☐ Document the setup and usage of the database
  - Write a README file with instructions on how to set up the database
  - Include details on how to run migrations and seed the database
  - Provide examples of API requests for CRUD operations
☐ Review and optimize database performance
    - Analyze query performance and optimize slow queries
    - Consider indexing frequently queried fields
    - Monitor database performance metrics and adjust configurations as needed
☐ Prepare for deployment
  - Ensure the database is secure and accessible only to authorized users
    - Backup the database before deployment
    - Document the deployment process for the database
☐ Finalize the project
  - Review all code and documentation

    - Ensure all tasks are completed and tested
    - Prepare a final report summarizing the project
    - Conduct a code review with team members
    - Address any feedback and make necessary adjustments
    - Archive the project repository and documentation for future reference
    - Celebrate the successful completion of the project! 
☐ Establish mobile-first design system
  - Define color palette tokens (charcoal base, ember orange, arcane teal, gilded bronze, parchment neutrals)
  - Set up responsive typography scale with clamp() and select heading/body fonts
  - Replace global styles with CSS reset, spacing scale, and dark-first theme variables
☐ Build shared UI component library
  - Implement Button, Card, Container/Stack/Grid primitives, and FilterChip variations
  - Create ProgressRing, StatusBadge, and FloatingActionButton components with accessibility states
  - Document component usage patterns for future Storybook or design tokens export
✔ Replace Vite starter UI with grail data connectivity prototype @done(25-09-24 09:45)
  - Render items fetched from `/api/items` to validate client-backend wiring @done(25-09-24 09:45)

☐ Scaffold grail dashboard shell
  - Introduce React Router layout with top app bar, responsive rail, and route slots
  - Move the prototype items view into the dashboard content region
  - Add placeholder navigation for future screens (browser, detail, stats, settings)
☐ Establish frontend data layer
  - Extract typed API client wrapper around `fetch` with shared error handling
  - Introduce TanStack Query (or similar) for caching and suspense-friendly hooks
  - Surface request failures via inline toasts and retry affordances
☐ Build item browser experience
  - Add search input and filter chips for rarity, slot, runeword, and mode with TanStack Query-backed data
  - Design item row component with status toggles and expandable detail drawer for drop sources and variants
  - Include floating action button for quick "Add find" logging with optimistic update flow
☐ Create item detail view
  - Implement hero banner with rarity ribbon, item art, and quick action buttons
  - Add tabs/accordions for Overview, Drop Sources, Variants, and Notes with responsive collapse behaviour
  - Wire external link button for wiki reference and track outbound analytics event
☐ Implement Sets & Runewords page
  - Build collection cards with progress bars, checklist modal/sheet, and assignment placeholders
  - Support toggling between set and runeword views with filter chips and saved URL params
  - Surface trading collaboration notes panel for future real-time sync
☐ Develop statistics & insights page
  - Display overall completion snapshot and rarity breakdown cards with responsive charts
  - Prototype drop source heatmap and act progression timelines with lightweight SVG components
  - Provide export/share controls for progress summaries (image + CSV)
☐ Refresh settings & data management
  - Organize sections for account, appearance, data, and onboarding with inline forms
  - Add theme toggles (dark, light, high-contrast) and sync status indicators
  - Outline import/export flows aligned with backend endpoints and offline safeguards
