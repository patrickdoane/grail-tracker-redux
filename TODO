✔ Setup postgres database on development machine @done(25-08-19 08:18)
  ✔ Install PostgreSQL @done(25-08-19 08:18)
  ✔ Create a new database for the project @done(25-08-19 08:18)
  ✔ Configure database connection settings in the application @done(25-08-19 08:18)
    ✔ Save connection details in a `.env` file @done(25-08-19 08:18)
    ✔ Backup secrets somewhere secure @done(25-08-19 08:18)

✔ Create database schema @started(25-08-19 08:26) @done(25-08-23 07:32) @lasted(3d23h6m35s)
  ✔ Define models for the application @started(25-08-21 00:30) @done(25-08-23 07:32) @lasted(2d7h2m36s)
  ✔ Use a migration tool to create the initial schema @done(25-08-23 07:32)
    ✔ Run migrations to set up tables and relationships @done(25-08-23 07:32)
  ✔ Verify schema by checking the database structure @done(25-08-23 07:32)

✔ Seed the database with initial data from the provided CSV files @started(25-08-23 07:44) @done(25-09-20 16:00) @lasted(4w8h16m55s)
  ✔ Write scripts to read CSV files and insert data into the database @started(25-09-18 15:12) @done(25-09-20 16:00) @lasted(2d48m56s)
  ✔ Ensure data integrity and consistency during the seeding process @started(25-09-18 15:12) @done(25-09-20 16:00) @lasted(2d48m56s)
  ✔ Validate that the data has been correctly inserted by querying the database @done(25-09-20 16:00)

✔ Implement basic CRUD operations for the main entities @done(25-09-20 16:46)
  ✔ Create endpoints for creating, reading, updating, and deleting records @done(25-09-20 16:46)
    ✔ Test each endpoint to ensure they work as expected @done(25-09-24 09:30)
✔ Set up a development environment for testing @done(25-09-24 09:30)
  ✔ Use a testing framework to write unit and integration tests @done(25-09-24 09:30)
    ✔ Create test cases for the CRUD operations (CrudIntegrationTests) @done(25-09-24 09:30)
    ✔ Run tests to ensure functionality and catch any bugs early @done(25-09-24 09:30)
✔ Replace Vite starter UI with grail data connectivity prototype @done(25-09-24 09:45)
  - Render items fetched from `/api/items` to validate client-backend wiring @done(25-09-24 09:45)

✔ Establish mobile-first design system @done(25-09-24 10:45)
  ✔ Lock in palette tokens (charcoal, ember, teal, bronze, parchment) and typography scale @done(25-09-24 10:45)
  ✔ Extend global styles with spacing scale and dark-first theme variables @done(25-09-24 10:45)
✔ Build shared UI component library @started(25-09-22 01:54) @done(25-09-25 08:45) @lasted(3d6h51m)
  ✔ Implement Button, Card, Container/Stack/Grid, and FilterChip primitives @done(25-09-24 22:10)
  ✔ Add ProgressRing, StatusBadge, and FloatingActionButton with accessible states @done(25-09-24 22:10)
  ✔ Document usage patterns for future Storybook/design tokens export @done(25-09-24 22:20)
✔ Scaffold grail dashboard shell @done(25-09-21 17:41)
  ✔ Introduce React Router layout with top app bar, responsive rail, and route slots @done(25-09-21 17:41)
  ✔ Move the prototype items view into the dashboard content region @done(25-09-21 17:41)
  ✔ Add placeholder navigation for browser, detail, stats, and settings screens @done(25-09-21 17:41)
✔ Establish frontend data layer @started(25-09-25 09:05) @done(25-09-25 10:20) @lasted(1h15m)
  ✔ Extract typed API client wrapper around `fetch` with shared error handling @done(25-09-25 10:05)
  ✔ Introduce TanStack Query (or similar) for caching and background refresh @done(25-09-25 10:10)
  ✔ Surface request failures via inline toasts and retry affordances @done(25-09-25 10:15)
✔ Build item browser experience @started(25-09-25 10:30) @done(25-09-25 11:45) @lasted(1h15m)
  ✔ Add search input and filter chips for rarity, slot, runeword, and mode @done(25-09-25 11:20)
  ✔ Design item row component with status toggles and expandable detail drawer @done(25-09-25 11:35)
  ✔ Include floating action button for quick "Add find" logging with optimistic updates @done(25-09-25 11:40)
☐ Create item detail view @started(25-09-23 09:32)
  ✔ Implement hero banner with rarity ribbon, item art, and quick action buttons @done(25-09-23 08:33)
  ✔ Add Overview, Drop Sources, Variants, and Notes tabs/accordions with responsive collapse @done(25-09-23 17:13)
    ✔ Ship tabbed + accordion variant layout with fallback list for legacy paths @done(25-09-23 17:13)
  ✔ Wire external wiki link and track outbound analytics event @done(25-09-23 18:26)
  - Stand up telemetry capture for detail interactions (defer until post-UX polish)
    - Define outbound link event contract and payload requirements (defer until post-UX polish)
    - Implement telemetry queue/transport with sendBeacon + fetch fallback (defer until post-UX polish)
    - Integrate wiki button clicks with telemetry client @done(25-09-23 09:14)
    ✔ Expose `VITE_TELEMETRY_ENDPOINT` configuration and document rollout steps @done(25-09-25 12:20)
  ✔ Surface runeword recipe guidance in Overview panel @done(25-09-23 16:02)
  ✔ Enable rune-by-rune tracking (mark owned, deep link to rune entries) @done(25-09-25 13:05)
    - TODO: Persist rune ownership via backend API once UX stabilization is complete
✔ Implement Sets & Runewords page @started(25-09-23 09:32) @done(25-09-23 15:49) @lasted(6h17m)
  ✔ Build collection cards with progress bars and checklist modal/sheet @done(25-09-23 09:39)
  ✔ Support toggling between set/runeword views with filter chips and saved URL params @done(25-09-23 09:45)
  ✔ Surface trading collaboration notes panel for future real-time sync @done(25-09-23 10:05)
  ✔ Extend data pipeline to include runewords @done(25-09-23 15:49)
    ✔ Update `scripts/d2_holy_grail_scraper.py` to capture runeword recipes and components @done(25-09-23 15:48)
    ✔ Refresh `scripts/make_official_reference.py` to persist runewords alongside sets @done(25-09-23 15:48)
    ✔ Expand `scripts/seed_database.py` to import runeword records and related metadata @done(25-09-23 15:49)
☐ Develop statistics & insights page
  ✔ Display completion snapshot and rarity breakdown cards with responsive charts @done(25-09-23 21:38)
  - Prototype drop-source heatmap and act progression timelines (lightweight SVG)
  - Provide export/share controls for progress summaries (image + CSV)
  - Prioritize prototype to drive metrics requirements
  - Layer timeframe toggles (7-day, 30-day, lifetime) across charts to contextualize trends
  - Break down completion snapshot by item category (uniques, sets, runewords, runes)
  - Forecast grail completion velocity using recent find cadence
  - Surface recent milestones and streak callouts alongside insight copy
  ✔ Replace placeholder drop activity visualization with a real chart wired to the selected metric @done(25-09-23 22:16)
  ✔ Feed cards and charts from live profile statistics instead of hard-coded demo data @done(25-09-23 22:29)
  - Author dynamic insight copy that highlights notable trends or outliers from the player's recent runs
✔ Refresh settings & data management @started(25-09-26 08:05) @done(25-09-26 09:55) @lasted(1h50m)
  ✔ Organize account, appearance, data, and onboarding sections with inline forms @done(25-09-26 09:05)
  ✔ Add theme toggles (dark, light, high-contrast) and sync status indicators @done(25-09-26 09:15)
  ✔ Outline import/export flows aligned with backend endpoints and offline safeguards @done(25-09-26 09:35)
  ✔ Prototype shell early to host future auth + data controls @done(25-09-26 09:55)
☐ Establish user authentication & authorization
  - Evaluate options (Spring Security vs. managed IdP)
  - Define user model and persistence
  - Add signup/login/logout flows to client shell
  - Gate server-side rune ownership persistence on auth rollout
☐ Document database setup and API usage
  - Expand README with Postgres install, migrations/seed instructions, and env guidance
  - Add sample API requests covering CRUD flows and filtering
☐ Review and optimize database performance
  - Analyze key queries, add indexes where needed, and baseline metrics
  - Monitor for slow queries once item browser filters ship
☐ Prepare for deployment
  - Lock down database access, configure backups, and capture deployment runbook
  - Validate client/server build pipelines and environment variables
☐ Finalize the project
  - Perform end-to-end QA, close documentation gaps, and collect feedback
  - Conduct final code review, address findings, and archive artifacts
